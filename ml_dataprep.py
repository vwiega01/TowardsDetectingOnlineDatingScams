# -*- coding: utf-8 -*-
"""ML_DataPrep.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZcOylRXzd6UCk8a3Q0Rb8T-hiVoey-4T

# Prepare Data for Machine Learning Model
"""

# mounting to google drive
import google.colab
from google.colab import drive
drive.mount('/content/drive/')

import pandas as pd

"""1) Import excel file into pandas data frame"""

df_profiles = pd.read_excel('/content/drive/MyDrive/VURF/Google_Collabs/all_profiles_excel.xlsx')
df_profiles.head()

df_profiles.head()

"""2) Remove sensitive or uncomprehensive column features:

*   name
*   email
*   phone
*   match_age
*   children
*   orientation
*   religion
*   smoking
*   drinking
*   month_reported
*   year_reported
*   inet

"""

# only include desired columns/features
df_profiles = df_profiles[['username', 'age', 'gender', 'status', 'ethnicity',
                           'occupation', 'location', 'description','intent', 
                           'tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 
                           'tag7', 'tag8', 'tag9', 'file_path', 'scam']]
df_profiles.info()

df_profiles.head()

"""3.1) Fix cases where 'age' is not a single integer"""

# testing on one string
age_string = '20 or 30'.split(' ')
print(age_string)
if len(age_string) > 2:
  average = int((int(age_string[0]) + int(age_string[2]))/2)
  age_string = str(average)

age_string = int(age_string)
print(age_string)

# create test data frame with age format # or #
test_profiles1 = pd.concat([df_profiles.iloc[[10915]], df_profiles.iloc[[10916]], df_profiles.iloc[[4]]])
test_profiles1.head()

# testing on sample data set
test_profiles1 = test_profiles1.astype({"age": str}) # set type to string
for i in test_profiles1.index:
    age_string = test_profiles1['age'][i].split(' ')
    print(age_string)
    # checks if age has the 'or' format
    if len(age_string) > 2: 
      # gets the average of the 2 ages
      average = int((int(age_string[0]) + int(age_string[2]))/2)
      average = str(average)
      print(average)
      # set average to age
      test_profiles1['age'][i] = average
# set type back to int
test_profiles1 = test_profiles1.astype({"age": int})
test_profiles1.info()

# **** fixing special cases ****
# row 10770 has different format than the rest
print(df_profiles['age'][10770])
average = int((22 + 23 + 26)/3)
print(average)
df_profiles['age'][10770] = average
print(df_profiles['age'][10770])

# the rows in the list have the format '# or # or #'
rows = [10168, 10651, 11045, 11145, 11409, 11427, 11485, 11528, 11549, 12058, 12707, 12736, 12880, 13768]
# set type to string
df_profiles = df_profiles.astype({"age": str}) 
# loop through indexes in the list rows
for i in rows:
    age_string = df_profiles['age'][i].split(' ')
    # take the average of the 3 ages
    average = int((int(age_string[0]) + int(age_string[2]) + int(age_string[4]))/3)
    average = str(average)
    # set age to average
    df_profiles['age'][i] = average
# check a row
print(df_profiles['age'][11409])

# **** running on whole dataset *****
# set 'age' column type to string
df_profiles = df_profiles.astype({"age": str})
# loop through data frame
for i in df_profiles.index:
    age_string = df_profiles['age'][i].split(' ')
    # checks if age has the 'or' format
    if len(age_string) > 2:
      average = int((int(age_string[0]) + int(age_string[2]))/2)
      average = str(average)
       # set average to age
      df_profiles['age'][i] = average
df_profiles.info()

# send to excel file
df_profiles_copy = df_profiles.copy()
df_profiles_copy.to_excel(r'/content/drive/MyDrive/VURF/Google_Collabs/df_profiles_excel.xlsx', header=True)

"""3.2) Remove values where 'age' is 'nan', where username is also NULL"""

# **** testing on sample data set ****
# creating test set
test_profiles2 = pd.concat([df_profiles.iloc[[12250]], df_profiles.iloc[[12251]], 
                            df_profiles.iloc[[12252]], df_profiles.iloc[[12040]], 
                            df_profiles.iloc[[12037]]])
test_profiles2.head()

# running tests
for i in test_profiles2.index:
  if test_profiles2['age'][i] == 'nan':
    test_profiles2 = test_profiles2.drop(i)
test_profiles2.head()

# **** running on whole set ****
for i in df_profiles.index:
  if df_profiles['age'][i] == 'nan':
    df_profiles = df_profiles.drop(i)
df_profiles = df_profiles.reset_index()

# send to excel file
df_profiles_copy = df_profiles.copy()
df_profiles_copy.to_excel(r'/content/drive/MyDrive/VURF/Google_Collabs/df_profiles2_excel.xlsx', header=True)

"""3.3) Convert 'age' to an integer"""

df_profiles = df_profiles.astype({"age": int})

"""4) Remove rows where 'username' is NULL"""

# list of rows where username is NULL
rows2 = [9984, 10227, 10298, 10337, 10417, 10829, 10861, 12228]
# loop through indexes from the list rows2
for i in rows2:
  df_profiles = df_profiles.drop(i) # drop the row
df_profiles = df_profiles.reset_index()

df_profiles = df_profiles.drop(columns='level_0')
df_profiles = df_profiles.drop(columns='index')
df_profiles.head()

# send to excel file
df_profiles_copy = df_profiles.copy()
df_profiles_copy.to_excel(r'/content/drive/MyDrive/VURF/Google_Collabs/df_profiles3_excel.xlsx', header=True)

"""5) Create ordinal encoding for 'status', 'ethnicity', 'occupation'"""

# for new runtime
df_profiles = pd.read_excel('/content/drive/MyDrive/VURF/Google_Collabs/df_profiles3_excel.xlsx')
df_profiles = df_profiles.drop(columns='Unnamed: 0')
df_profiles = df_profiles.astype({"scam": int})

import sklearn
import sklearn_pandas
from sklearn.preprocessing import OrdinalEncoder

# **** testing on sample set ****
# list of object columns
oe_cols = ['gender', 'status', 'ethnicity', 'occupation']

ordinal_encoder = OrdinalEncoder()
test_profiles_oe = pd.concat([df_profiles.iloc[[10740]], df_profiles.iloc[[12154]],
                              df_profiles.iloc[[10920]], df_profiles.iloc[[12161]],
                              df_profiles.iloc[[11172]]])
test_profiles_oe.head()

"""*** null values are not considered in ordinal encoding"""

# fill null values with string 'null' as place holder for encoder
test_profiles_oe["status"].fillna("null", inplace = True)
test_profiles_oe["ethnicity"].fillna("null", inplace = True)
test_profiles_oe["occupation"].fillna("null", inplace = True)
test_profiles_oe.head()

# run ordinal encoder on test set
test_profiles_oe[oe_cols] = ordinal_encoder.fit_transform(test_profiles_oe[oe_cols])
test_profiles_oe.head()

# **** running on entire data frame ****
# make copy of data frame
df_profiles_oe = df_profiles.copy()

# columns that will be encoded
oe_cols = ['gender', 'status', 'ethnicity', 'occupation']
ordinal_encoder = OrdinalEncoder()

# fill null values with string 'null' as place holder for encoder
df_profiles_oe["status"].fillna("null", inplace = True)
df_profiles_oe["ethnicity"].fillna("null", inplace = True)
df_profiles_oe["occupation"].fillna("null", inplace = True)

# run ordinal encoder
df_profiles_oe[oe_cols] = ordinal_encoder.fit_transform(df_profiles_oe[oe_cols])
df_profiles_oe.head()

"""6) Create ordinal encoding for 'intent' and make scam profiles have "scam" intent"""

# **** testing ****
# testing to make scam profiles have "scam" intent
for i in test_profiles_oe.index:
  # check if the row is scam
  if test_profiles_oe['scam'][i] == 1:
    # set the intent to scam
    test_profiles_oe['intent'][i] = 'scam'
test_profiles_oe.head()

# set string 'null' place holder
test_profiles_oe['intent'].fillna("null", inplace = True)

# run ordinal encoder
oe_cols = ['intent']
test_profiles_oe[oe_cols] = ordinal_encoder.fit_transform(test_profiles_oe[oe_cols])
test_profiles_oe.head()

# **** running on dataframe ****
# make scam profiles have "scam" intent 
for i in df_profiles_oe.index:
  # check if the row is scam
  if df_profiles_oe['scam'][i] == 1:
    # set the intent to scam
    df_profiles_oe['intent'][i] = 'scam'

# check if worked
print(df_profiles_oe.iloc[[11140]])

# set string 'null' place holder
df_profiles_oe['intent'].fillna("null", inplace = True)

# run ordinal encoder
oe_cols = ['intent']
df_profiles_oe[oe_cols] = ordinal_encoder.fit_transform(df_profiles_oe[oe_cols])
df_profiles_oe.head()

# send to excel file
df_profiles_oe_copy = df_profiles_oe.copy()
df_profiles_oe_copy.to_excel(r'/content/drive/MyDrive/VURF/Google_Collabs/df_profiles4_excel.xlsx', header=True)

"""7.1) Extract Country from 'location' and create 'country' feature"""

# for new runtime
df_profiles = pd.read_excel('/content/drive/MyDrive/VURF/Google_Collabs/df_profiles4_excel.xlsx')
df_profiles = df_profiles.drop(columns='Unnamed: 0')
df_profiles = df_profiles.astype({"scam": int})

# small sample of dataset for testing
test_profiles = df_profiles.copy()
df_len = len(df_profiles)
for i in range(50,df_len):
    test_profiles = test_profiles.drop(i)
print(len(test_profiles))

# **** testing ****
import numpy as np
# special cases: row 12597, 12520, 12482, 12367, 12217
# split location based on (', ) and pick length-1 of list for country

# set to store all the countries
countries_t = set()
# create null 'country' feature to hold the extracted countries
test_profiles['country'] = np.nan

# loop through data frame
for i in test_profiles.index:
  # extract country and set it to 'country' feature
  country = test_profiles['location'][i].split(', ')
  country = country[len(country)-1]
  test_profiles['country'][i] = country
  # add the country to the set
  countries_t.add(country)

test_profiles.head()

import numpy as np
# **** running on whole set ****
# set to store all the countries
countries = set()
# create null 'country' feature to hold the extracted countries
df_profiles['country'] = np.nan
# make sure entire 'location' column are strings
df_profiles = df_profiles.astype({"location": str})

# figure out what country is represented from the rows that have postal codes
# list of country numbers featured
country_nums = ['02000', '09100', '14000', '25000', '36000', '39600', '40000', '46000', '49000', '50000', '54000', '58000', '59131', '65000', '68000', '69061', '73000', '73009', '75500', '77311', '79000', '81160', '85105', '87500']
# empty list to store the indexes of country number rows
country_nums_i = []

# loop through data frame
for i in df_profiles.index:
  # extract country from location string
  country = df_profiles['location'][i].split(', ')
  country = country[len(country)-1]
  # fix special cases: * if there is an 'or', the second country will be picked
  if country == 'or Dublin Ireland':
    country = 'Ireland'
  elif country == 'Noruega':
    country = 'Norway'
  elif country == 'Nueva Zelanda':
    country = 'New Zealand'  
  elif country == 'or Egypt':
    country = 'Egypt'
  elif country == 'Suecia':
    country = 'Sweden'
  elif country == 'or Switzerland':
    country = 'Switzerland'
  elif country == 'Prishtina':
    country = 'Kosovo'
  elif country == 'Rumanía':
    country = 'Romania'
  elif country == 'The Bahamas':
    country = 'Bahamas'
  elif country == 'Bangkok':
    country = 'Thailand'
  elif country == 'Brasil':
    country = 'Brazil'
  elif country == 'Canada or Kuwait':
    country = 'Kuwait'
  elif country == 'Curaçao':
    country = 'Curazao'
  elif country == 'España':
    country = 'Spain'
  elif country == 'Francia':
    country = 'France'
  elif country == 'Gauteng':
    country = 'South Africa'
  elif country == 'Guinea Ecuatorial':
    country = 'Equatorial Guinea'
  elif country == 'Islas Caimán':
    country = 'Cayman Islands'
  elif country == 'Italia' or country == 'or Milan Italy':
    country = 'Italy'
  elif country == 'Japón':
    country = 'Japan'
  elif country == 'Lybia':
    country = 'Libya' 
  elif country == 'Macau':
    country = 'Macao'
  elif country == 'Macedonia (FYROM)':
    country = 'North Macedonia'
  elif country == 'Monrovia':
    country = 'Liberia'
  elif country == 'Panamá':
    country = 'Panama'
  elif country == 'Perú':
    country = 'Peru'
  elif country == 'Países Bajos' or country == 'or Netherlands':
    country = 'Netherlands'
  elif country == 'Rusia':
    country = 'Russia'
  elif country == 'Stockholm':
    country = 'Sweden'
  elif country == 'Sudan or Togo':
    country = 'Togo'
  elif country == 'Surinam':
    country = 'Suriname'
  elif country == 'The Gambia':
    country = 'Gambia'
  elif country == 'Trinidad y Tobago':
    country = 'Trinidad and Tobago'
  elif country == 'Turquía':
    country = 'Turkey'
  elif country == 'USVI':
    country = 'U.S. Virgin Islands'
  elif country == 'United States or Haiti':
    country = 'Haiti'
  elif country == 'or Andorra':
    country = 'Andorra'
  elif country == 'or Germany':
    country = 'Germany'
  elif country == 'or Greece':
    country = 'Greece'
  elif country == 'or Guatelmala':
    country = 'Guatemala'
  elif country == 'or Hong Kong':
    country = 'Hong Kong'
  elif country == 'or Luxembourg':
    country = 'Luxembourg'
  elif country == 'or Lybia':
    country = 'Libya'
  elif country == 'or Malaysia':
    country = 'Malaysia'
  elif country == 'or Poland':
    country = 'Poland'
  elif country == 'or Syria':
    country = 'Syria'
  elif country == '2112 Hungary':
    country = 'Hungary'
  # Mexico
  elif country == 'United States or Mexico' or country == 'México' or country == 'or Mexico':
    country = 'Mexico'
  # Canada
  elif country == 'Canadá' or country == 'or Canada' or country == 'United States or Canada' or country == 'Ontario':
    country = 'Canada'
  # USA
  elif country == 'EE. UU.' or country == 'Texas United States' or country == 'Florida' or country == 'United States' or country == 'Germany or United States' or country == 'United State' or country == 'United StatesUsername Beckymorr' or country == 'United states' or country == 'united state of american':
    country = 'USA'
  # United Arab Emirates
  elif country == 'UAE' or country == 'Sharjah - United Arab Emirates' or country == 'Dubai - United Arab Emirates' or country == 'Al Satwa - Dubai - United Arab Emirates' or country == 'Abu Dhabi - United Arab Emirates':
    country = 'United Arab Emirates'
  # Saudi Arabia
  elif country == 'Al Jubail Saudi Arabia' or country == 'Jeddah Saudi Arabia' or country == 'Ras Tanura Saudi Arabia' or country == 'Riyadh Saudi Arabia':
    country = 'Saudi Arabia'
  # Cyprus
  elif country == 'Lefka' or country == 'Karavostasi. Cyprus' or country == 'Girne' or country == 'Famagusta':
    country = 'Cyprus'
  # Dominican Republic
  elif country == 'República Dominicana' or country == 'Dominica':
    country = 'Dominican Republic'
  # UK
  elif country == 'Reino Unido' or country == 'England' or country == 'United Kindom' or country == 'United Kingdom' or country == 'United Kngdom' or country == '\xa0United Kingdom':
    country = 'UK'
  # check country nums and add index to list
  # if country in country_nums: ALREADY COMPLETED
  #   country_nums_i.append(i)
  # all country codes were found to be for the Ukraine
  elif country in country_nums:
    country = 'Ukraine'
  else:
    pass
  # set country to the 'country' feature
  df_profiles['country'][i] = country
  # add the country to the set
  countries.add(country)

# set all null countries to "null" place holder for encoder
df_profiles['country'].fillna("null", inplace = True)

print(sorted(countries)) # set of all the countries featured in the data frame
print(country_nums_i) # list of indexes that have country numbers

# print out the location column for the rows that have a code as the 'country' column
for i in country_nums_i:
  print('row ' + str(i))
  print(df_profiles['location'][i])
  print('***********************************************')
# ----> all of them are Ukraine

# send to excel file to see if country is ready for ordinal encoding
df_profiles_country = df_profiles.copy()
df_profiles_country.to_excel(r'/content/drive/MyDrive/VURF/Google_Collabs/df_profiles_country_excel.xlsx', header=True)
# -> READY

"""7.2) Ordinal encode 'country' feature"""

# ordinal encoder imports
import sklearn
import sklearn_pandas
from sklearn.preprocessing import OrdinalEncoder

# remove 'location' column and reorganize columns
df_profiles = df_profiles[['username', 'age', 'gender', 'status', 'ethnicity',
                           'occupation', 'country', 'description','intent', 
                           'tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 
                           'tag7', 'tag8', 'tag9', 'file_path', 'scam']]

# ordinal encode 'country'
df_profiles_coe = df_profiles.copy()
oe_cols = ['country']
ordinal_encoder = OrdinalEncoder()
df_profiles_coe[oe_cols] = ordinal_encoder.fit_transform(df_profiles_coe[oe_cols])

df_profiles_coe.head()

# send to excel file
df_profiles_coe.to_excel(r'/content/drive/MyDrive/VURF/Google_Collabs/df_profiles_countryX_excel.xlsx', header=True)

"""8.1) Remove 'tag1' column and readjust names"""

# for new runtime
df_profiles = pd.read_excel('/content/drive/MyDrive/VURF/Google_Collabs/df_profiles_countryX_excel.xlsx')
df_profiles.head()

# drop tag1 column
df_profiles = df_profiles.drop(columns='tag1')

# rename columns
df_profiles = df_profiles.rename(columns={'tag2': 'tag1', 'tag3': 'tag2', 'tag4': 'tag3', 'tag5': 'tag4', 'tag6': 'tag5', 'tag7': 'tag6', 'tag8': 'tag7', 'tag9': 'tag8'})

df_profiles.head()

"""8.2) Give real profiles a 'datingnmore', reffering to the dating site, tag in 'tag1' column"""

# small sample of dataset for testing
test_profiles = df_profiles.copy()
df_len = len(df_profiles)
for i in range(50,df_len):
    test_profiles = test_profiles.drop(i)
print(len(test_profiles))

# **** testing ****
# if profile is real it receives a 'datingnmore' tag
for i in test_profiles.index:
  if test_profiles['scam'][i] == 0: # real profile
    test_profiles['tag1'][i] = 'datingnmore'
test_profiles.head()

# ***** running on whole set *****
# if profile is real it receives a 'datingnmore' tag
for i in df_profiles.index:
  if df_profiles['scam'][i] == 0: # real profile
    df_profiles['tag1'][i] = 'datingnmore'

df_profiles.head()

"""8.3) Ordinal encode the tag(1-8) columns

"""

# ordinal encoder imports
import sklearn
import sklearn_pandas
from sklearn.preprocessing import OrdinalEncoder

# set null values to 'null' string for a placeholder
df_profiles['tag1'].fillna("null", inplace = True)
df_profiles['tag2'].fillna("null", inplace = True)
df_profiles['tag3'].fillna("null", inplace = True)
df_profiles['tag4'].fillna("null", inplace = True)
df_profiles['tag5'].fillna("null", inplace = True)
df_profiles['tag6'].fillna("null", inplace = True)
df_profiles['tag7'].fillna("null", inplace = True)
df_profiles['tag8'].fillna("null", inplace = True)

# ordinal encode tag1-8 columns
df_profiles_toe = df_profiles.copy()
oe_cols = ['tag1', 'tag2', 'tag3', 'tag4', 'tag5', 'tag6', 'tag7', 'tag8']
ordinal_encoder = OrdinalEncoder()
df_profiles_toe[oe_cols] = ordinal_encoder.fit_transform(df_profiles_toe[oe_cols])

df_profiles_toe.head()

# send to excel file
df_profiles_toe.to_excel(r'/content/drive/MyDrive/VURF/Google_Collabs/df_profiles_ALMOST_excel.xlsx', header=True)

"""**LAST STEP:** all columns need to be numbers that are ordinal encoded

*   rename 'Unnamed: 0' to index
*   remove 'tag7' and 'tag8' column because they have no values
*   remove username and file_path for ML model because they are unique identifiers

"""

# copy data frame to new data frame
ml_profiles = df_profiles_toe.copy()

# rename unamed to index
ml_profiles = ml_profiles.rename(columns={'Unnamed: 0': 'index'})

# tag7 and tag8 have nothing
ml_profiles = ml_profiles.drop(columns={'tag7', 'tag8'})

# remove username and file path
ml_profiles = ml_profiles.drop(columns={'username', 'file_path'})

# another data frame with descriptions
ml_profiles_des = ml_profiles.copy
ml_profiles = ml_profiles.drop(columns='description')

# view machine learning ready model !!!
ml_profiles.head()

# send to excel file
ml_profiles.to_excel(r'/content/drive/MyDrive/VURF/Google_Collabs/ml_profiles_excel.xlsx', header=True)